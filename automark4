#! /usr/bin/env python
"""Detect moles in an image."""

import argparse
import sys

import cv2
import numpy as np

import mel.rotomap.moles
import mel.lib.common
import mel.rotomap.detectmolesnn


def setup_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "IMAGES", nargs="+", help="A list of paths to images to automark."
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Print information about the processing.",
    )
    parser.add_argument(
        "--extra-stem",
        help="Add an extra bit to the filename stem, e.g. '0.jpg.EXTRA.json'.",
    )
    parser.add_argument(
        "--save-images",
        help="Save images of the processing.",
        action="store_true",
    )
    return parser


def main():
    parser = setup_parser()
    args = parser.parse_args()

    for path in args.IMAGES:
        if args.verbose:
            print(path)
        process_path(args, path)


def process_path(args, path):
    image_height = 251
    image_width = 188
    photo_height, photo_width = mel.lib.image.load_image(path).shape[0:2]
    scale_x = image_width / photo_width
    scale_y = image_height / photo_height
    data_y = rotoimage_to_y_tensor(
        path, image_width, image_height, scale_x, scale_y
    )

    # threshold = 0.5
    # data_y[data_y < threshold] = 0
    # data_y[data_y >= threshold] = 1
    # data_y[0][0][data_m.rename(None)[0] == 0] = 0

    if args.save_images:
        extra_suffix = ""
        if args.extra_stem:
            extra_suffix = f".{args.extra_stem}"
        image = data_y.detach().numpy() * 255
        image = np.uint8(image)
        image = image.transpose((1, 2, 0))
        # print(image[image[:,:,0] != 0])
        cv2.imwrite(str(path) + f"{extra_suffix}.automark4.png", image)

    pos_xy = y_tensor_to_posxy(data_y, 1 / scale_x, 1 / scale_y)
    moles = moles_from_posxy(pos_xy)
    mel.rotomap.moles.save_image_moles(moles, path, extra_stem=args.extra_stem)


def draw(tensor, x, y, xoff, yoff):
    if x < 0 or y < 0:
        return
    if x >= tensor.shape[2] or y >= tensor.shape[1]:
        raise ValueError("Co-ordinate out of bounds.", x, y)
    tensor[0][y][x] = 1.0
    tensor[1][y][x] = xoff
    tensor[2][y][x] = yoff


def rotoimage_to_y_tensor(path, image_width, image_height, scale_x, scale_y):
    # Import this as lazily as possible as it takes a while to import, so that
    # we only pay the import cost when we use it.
    import torch

    moles = mel.rotomap.moles.load_image_moles(path)
    y_data = torch.zeros([3, image_height, image_width])
    for mole in moles:
        mx, my = mole["x"], mole["y"]
        float_x = mx * scale_x
        float_y = my * scale_y
        new_x = int(float_x)
        new_y = int(float_y)
        x_off = float_x - (new_x + 0.5)
        y_off = float_y - (new_y + 0.5)
        draw(y_data, new_x, new_y, x_off, y_off)

    return y_data


def y_tensor_to_posxy(y_tensor, scale_x, scale_y):
    # Import this as lazily as possible as it takes a while to import, so that
    # we only pay the import cost when we use it.
    import torch

    pos_xy = []
    for y, x in torch.nonzero(y_tensor[0]):
        value, xoff, yoff = y_tensor[:, y, x]
        if value < 0.5:
            continue
        pos_xy.append(
            [int((x + 0.5 + xoff) * scale_x), int((y + 0.5 + yoff) * scale_y)]
        )

    return pos_xy


def moles_from_posxy(pos_xy):
    moles = []
    for x, y in pos_xy:
        mel.rotomap.moles.add_mole(moles, int(x), int(y))
    return moles


if __name__ == "__main__":
    sys.exit(main())
