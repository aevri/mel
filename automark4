#! /usr/bin/env python
"""Detect moles in an image."""

import argparse
import sys

import cv2
import numpy as np

import mel.rotomap.moles
import mel.lib.common
import mel.rotomap.detectmolesnn


def setup_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "IMAGES", nargs="+", help="A list of paths to images to automark."
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Print information about the processing.",
    )
    parser.add_argument(
        "--extra-stem",
        help="Add an extra bit to the filename stem, e.g. '0.jpg.EXTRA.json'.",
    )
    parser.add_argument(
        "--save-images",
        help="Save images of the processing.",
        action="store_true",
    )
    return parser


def main():
    parser = setup_parser()
    args = parser.parse_args()

    for path in args.IMAGES:
        if args.verbose:
            print(path)
        process_path(args, path)


def process_path(args, path):
    data_y = rotoimage_to_y_tensor(path)

    # threshold = 0.5
    # data_y[data_y < threshold] = 0
    # data_y[data_y >= threshold] = 1
    # data_y[0][0][data_m.rename(None)[0] == 0] = 0

    if args.save_images:
        extra_suffix = ""
        if args.extra_stem:
            extra_suffix = f".{args.extra_stem}"
        image = data_y.detach().numpy() * 255
        image = np.uint8(image)
        image = image.transpose((1, 2, 0))
        # print(image[image[:,:,0] != 0])
        cv2.imwrite(str(path) + f"{extra_suffix}.automark4.png", image)

    return
    pos_xy = y_tensor_to_rotoimage(data_y)
    moles = moles_from_posxy(pos_xy)
    mel.rotomap.moles.save_image_moles(moles, path, extra_stem=args.extra_stem)


def draw(tensor, x, y, xoff, yoff):
    if x < 0 or y < 0:
        return
    if x >= tensor.shape[2] or y >= tensor.shape[1]:
        raise ValueError("Co-ordinate out of bounds.", x, y)
    tensor[0][y][x] = 1.0
    tensor[1][y][x] = xoff
    tensor[2][y][x] = yoff


def rotoimage_to_y_tensor(path):
    # Import this as lazily as possible as it takes a while to import, so that
    # we only pay the import cost when we use it.
    import torch

    image_height = 251
    image_width = 188

    # Make new image.
    # Iterate over moles.
    # Paint into image.

    photo_height, photo_width = mel.lib.image.load_image(path).shape[0:2]
    scale_x = image_width / photo_width
    scale_y = image_height / photo_height
    moles = mel.rotomap.moles.load_image_moles(path)
    y_data = torch.zeros([3, image_height, image_width])
    for mole in moles:
        mx, my = mole["x"], mole["y"]
        float_x = mx * scale_x
        float_y = my * scale_y
        new_x = int(float_x)
        new_y = int(float_y)
        x_off = new_x - (float_x + 0.5)
        y_off = new_y - (float_y + 0.5)
        draw(y_data, new_x, new_y, x_off, y_off)

    return y_data


def locations_image(moles, image_width, image_height):
    image = mel.lib.common.new_image(image_height, image_width)

    mole_points = [
        (m["x"], m["y"])
        for m in moles
        if "looks_like" not in m or m["looks_like"] == "mole"
    ]

    for x, y in mole_points:
        mel.lib.common.draw_circle(image, x, y, 32, (0, 0, 255))

    return image


def y_tensor_to_rotoimage(y_tensor):
    assert False


def moles_from_posxy(pos_xy):
    moles = []
    for x, y in pos_xy:
        mel.rotomap.moles.add_mole(moles, int(x), int(y))
    return moles


if __name__ == "__main__":
    sys.exit(main())
