#! /usr/bin/env python
"""Detect moles in an image."""

import argparse
import sys

import cv2
import numpy as np

import mel.rotomap.moles
import mel.lib.common
import mel.rotomap.detectmolesnn


def setup_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "IMAGES", nargs="+", help="A list of paths to images to automark."
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Print information about the processing.",
    )
    parser.add_argument(
        "--extra-stem",
        help="Add an extra bit to the filename stem, e.g. '0.jpg.EXTRA.json'.",
    )
    parser.add_argument(
        "--save-images",
        help="Save images of the processing.",
        action="store_true",
    )
    return parser


def make_model():
    # Import this as lazily as possible as it takes a while to import, so that
    # we only pay the import cost when we use it.
    import torch

    melroot = mel.lib.fs.find_melroot()
    model_dir = melroot / mel.lib.fs.DEFAULT_CLASSIFIER_PATH
    model_path = model_dir / "automark2.pth"
    # metadata_path = model_dir / "automark2.json"

    model = mel.rotomap.detectmolesnn.CackModel(total_steps=0)
    model.load_state_dict(torch.load(model_path))

    return model


def write_result(result, path):
    cv2.imwrite(path, result.detach().numpy()[0][0] * 255)


def main():
    parser = setup_parser()
    args = parser.parse_args()

    model = make_model()

    for path in args.IMAGES:
        if args.verbose:
            print(path)
        process_path(args, path, model)


def process_path(args, path, model):
    # Import this as lazily as possible as it takes a while to import, so that
    # we only pay the import cost when we use it.
    import torch

    data_x, data_m = rotoimage_to_xm_tensors(path)
    dataloader = torch.utils.data.DataLoader(
        data_x.rename(None).unsqueeze(0), batch_size=1
    )
    assert len(dataloader) == 1
    model.eval()
    with torch.no_grad():
        for x in dataloader:
            data_y = model(x)

    threshold = 0.5
    data_y[data_y < threshold] = 0
    data_y[data_y >= threshold] = 1
    data_y[0][0][data_m.rename(None)[0] == 0] = 0

    if args.save_images:
        extra_suffix = ""
        if args.extra_stem:
            extra_suffix = f".{args.extra_stem}"
        write_result(data_y, str(path) + f"{extra_suffix}.automark2.png")
        write_contour_image(
            data_y, str(path) + f"{extra_suffix}.automark2.contour.png"
        )

    pos_xy = pos_xy_from_contours(data_y)
    moles = moles_from_posxy(pos_xy)
    mel.rotomap.moles.save_image_moles(moles, path, extra_stem=args.extra_stem)


def rotoimage_to_xm_tensors(path):
    # Import this as lazily as possible as it takes a while to import, so that
    # we only pay the import cost when we use it.
    import torch
    import torchvision

    to_tensor = torchvision.transforms.ToTensor()

    photo = mel.lib.image.load_image(path)
    mask = mel.rotomap.mask.load(path)
    photo_hsv = cv2.cvtColor(photo, cv2.COLOR_BGR2HSV)
    blur_photo = cv2.blur(photo, (64, 64))
    blur_photo_hsv = cv2.cvtColor(blur_photo, cv2.COLOR_BGR2HSV)
    blur_mask = cv2.blur(mask, (64, 64))
    x_data = torch.vstack(
        [
            to_tensor(x)
            for x in [
                photo,
                photo_hsv,
                blur_photo,
                blur_photo_hsv,
                blur_mask,
            ]
        ]
    )

    m_data = to_tensor(mask)
    assert m_data.shape[0] == 1, m_data.shape

    return (
        x_data.rename(*list("CHW")),
        m_data.rename(*list("CHW")),
    )


def moles_from_posxy(pos_xy):
    moles = []
    for x, y in pos_xy:
        mel.rotomap.moles.add_mole(moles, int(x), int(y))
    return moles


def pos_xy_from_contours(result):
    image = result.detach().numpy()[0][0] * 255
    image = np.uint8(image)
    _, image = cv2.threshold(image, 128, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(image, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
    pos_xy = []
    for contour in contours:
        if contour is not None and len(contour) > 5:
            # area = cv2.contourArea(contour)
            moments = cv2.moments(contour)
            if moments["m00"] != 0:
                cx = int(moments["m10"] / moments["m00"])
                cy = int(moments["m01"] / moments["m00"])
                pos_xy.append((cx, cy))
    return pos_xy


def write_contour_image(result, path):
    image = contour_image(result)
    cv2.imwrite(path, image)


def contour_image(result):
    image = result.detach().numpy()[0][0] * 255
    image = np.uint8(image)
    _, image = cv2.threshold(image, 128, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(image, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
    for contour in contours:
        if contour is not None and len(contour) > 5:
            # area = cv2.contourArea(contour)
            moments = cv2.moments(contour)
            if moments["m00"] != 0:
                cx = int(moments["m10"] / moments["m00"])
                cy = int(moments["m01"] / moments["m00"])
                mel.lib.common.draw_circle(image, cx, cy, 16, (128,))
    return image


if __name__ == "__main__":
    sys.exit(main())
